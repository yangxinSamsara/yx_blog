(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{448:function(e,t,a){"use strict";a.r(t);var s=a(34),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[e._v("#")]),e._v(" 性能优化")]),e._v(" "),a("p",[e._v("提升首屏的加载速度，是前端性能优化中**「最重要」**的环节，这里笔者梳理出一些 "),a("code",[e._v("常规且有效")]),e._v(" 的首屏优化建议")]),e._v(" "),a("p",[a("strong",[e._v("「目标：」")]),e._v(" 通过对比优化前后的性能变化，来验证方案的有效性，了解并掌握其原理")]),e._v(" "),a("h2",{attrs:{id:"_1、路由懒加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、路由懒加载"}},[e._v("#")]),e._v(" 1、路由懒加载")]),e._v(" "),a("p",[e._v("SPA 项目，一个路由对应一个页面，如果不做处理，项目打包后，会把所有页面打包成一个文件，"),a("strong",[e._v("「当用户打开首页时，会一次性加载所有的资源」")]),e._v("，造成首页加载很慢，降低用户体验")]),e._v(" "),a("p",[e._v("列一个实际项目的打包详情：")]),e._v(" "),a("ul",[a("li",[e._v("app.js 初始体积： "),a("code",[e._v("1175 KB")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0w9YPPRQhAUnDo0IXzQ1uYJdTyt5Kusu2ia5iaFjabbevibtUD3a9udIvw/640?",alt:"图片"}})]),e._v(" "),a("ul",[a("li",[e._v("app.css 初始体积："),a("code",[e._v("274 KB")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0vTh8yVWW54iavPBiards0xtNcLh7rEonzNdzZvaEchzFPkXQnAuGIbFA/640?",alt:"图片"}})]),e._v(" "),a("p",[e._v("将路由全部改成懒加载")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// 通过webpackChunkName设置分割后代码块的名字\nconst Home = () => import(/* webpackChunkName: "home" */ "@/views/home/index.vue");\nconst MetricGroup = () => import(/* webpackChunkName: "metricGroup" */ "@/views/metricGroup/index.vue");\n…………\nconst routes = [\n    {\n       path: "/",\n       name: "home",\n       component: Home\n    },\n    {\n       path: "/metricGroup",\n       name: "metricGroup",\n       component: MetricGroup\n    },\n    …………\n ]\n')])])]),a("p",[e._v("重新打包后，首页资源拆分为 app.js 和 home.js，以及对应的 css 文件")]),e._v(" "),a("ul",[a("li",[e._v("app.js："),a("code",[e._v("244 KB")]),e._v("、 home.js: "),a("code",[e._v("35KB")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0xnicvqUvBTGhLib9WfEWliaTnrP7hqqBcXob5P1EibnBC43pg4aSXSibichw/640?",alt:"图片"}})]),e._v(" "),a("ul",[a("li",[e._v("app.css："),a("code",[e._v("67 KB")]),e._v("、home.css: "),a("code",[e._v("15KB")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0WkHxTxxkFasPo79BMHLpjPnMWtDiavS4n8g6WFuVnkqkIKPEKDn7y6w/640?",alt:"图片"}})]),e._v(" "),a("p",[e._v("通过路由懒加载，该项目的首页资源压缩约 "),a("code",[e._v("52%")])]),e._v(" "),a("h3",{attrs:{id:"路由懒加载的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由懒加载的原理"}},[e._v("#")]),e._v(" 路由懒加载的原理")]),e._v(" "),a("p",[e._v("懒加载前提的实现：ES6 的动态地加载模块——"),a("code",[e._v("import()")])]),e._v(" "),a("blockquote",[a("p",[e._v("调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中\n——摘自**《webpack——模块方法》的 import()小节**")])]),e._v(" "),a("p",[e._v("要实现懒加载，就得先将进行懒加载的子模块分离出来，打包成一个单独的文件")]),e._v(" "),a("p",[e._v("webpackChunkName 作用是 webpack 在打包的时候，对异步引入的库代码（lodash）进行代码分割时，设置代码块的名字。webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中")]),e._v(" "),a("h2",{attrs:{id:"_2、组件懒加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、组件懒加载"}},[e._v("#")]),e._v(" 2、组件懒加载")]),e._v(" "),a("p",[e._v("除了路由的懒加载外，组件的懒加载在很多场景下也有重要的作用")]),e._v(" "),a("p",[e._v("举个 🌰：")]),e._v(" "),a("p",[e._v("home 页面 和 about 页面，都引入了 dialogInfo 弹框组件，该弹框不是一进入页面就加载，而是需要用户手动触发后才展示出来")]),e._v(" "),a("p",[e._v("home 页面示例：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<template>\n  <div class="homeView">\n    <p>home 页面</p>\n    <el-button @click="dialogVisible = !dialogVisible">打开弹框</el-button>\n    <dialogInfo v-if="dialogVisible" />\n  </div>\n</template>\n<script>\nimport dialogInfo from \'@/components/dialogInfo\';\nexport default {\n  name: \'homeView\',\n  components: {\n    dialogInfo\n  }\n}\n<\/script>\n')])])]),a("p",[e._v("项目打包后，发现 home.js 和 about.js 均包括了该弹框组件的代码（在 dist 文件中搜索 dialogInfo 弹框组件）")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0eZiaZtWiclk852us2aD5URWoqwbnwibYY5K9bzcywkplQyeeDMu48bn4Q/640?",alt:"图片"}})]),e._v(" "),a("p",[e._v("当用户打开 home 页时，会一次性加载该页面所有的资源，"),a("strong",[e._v("「我们期望的是用户触发按钮后，再加载该弹框组件的资源」")])]),e._v(" "),a("p",[e._v("这种场景下，就很适合用懒加载的方式引入")]),e._v(" "),a("p",[e._v("弹框组件懒加载：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<script>\nconst dialogInfo = () => import(/* webpackChunkName: \"dialogInfo\" */ '@/components/dialogInfo');\nexport default {\n  name: 'homeView',\n  components: {\n    dialogInfo\n  }\n}\n<\/script>\n")])])]),a("p",[e._v("重新打包后，home.js 和 about.js 中没有了弹框组件的代码，该组件被独立打包成 dialogInfo.js，"),a("strong",[e._v("「当用户点击按钮时，才会去加载 dialogInfo.js 和 dialogInfo.css」")])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0icWVHLrvltYPOeGCW3TDYiaxrgX3JCBOl9dUcOvqq8licRNbHX0eyZp2A/640?",alt:"图片"}})]),e._v(" "),a("p",[e._v("最终，使用组件路由懒后，该项目的首页资源进一步减少约 "),a("code",[e._v("11%")])]),e._v(" "),a("h3",{attrs:{id:"组件懒加载的使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件懒加载的使用场景"}},[e._v("#")]),e._v(" 组件懒加载的使用场景")]),e._v(" "),a("p",[e._v("有时资源拆分的过细也不好，可能会造成浏览器 http 请求的增多")]),e._v(" "),a("p",[e._v("总结出三种适合组件懒加载的场景：")]),e._v(" "),a("p",[e._v("1）该页面的 JS 文件体积大，导致页面打开慢，可以通过组件懒加载进行资源拆分，利用浏览器并行下载资源，提升下载速度（比如首页）")]),e._v(" "),a("p",[e._v("2）该组件不是一进入页面就展示，需要一定条件下才触发（比如弹框组件）")]),e._v(" "),a("p",[e._v("3）该组件复用性高，很多页面都有引入，利用组件懒加载抽离出该组件，一方面可以很好利用缓存，同时也可以减少页面的 JS 文件大小（比如表格组件、图形组件等）")]),e._v(" "),a("h2",{attrs:{id:"_3、合理使用-tree-shaking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、合理使用-tree-shaking"}},[e._v("#")]),e._v(" 3、合理使用 Tree shaking")]),e._v(" "),a("p",[e._v("Tree shaking 的作用：消除无用的 JS 代码，减少代码体积")]),e._v(" "),a("p",[e._v("举个 🌰：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// util.js\nexport function targetType(target) {\n  return Object.prototype.toString.call(target).slice(8, -1).toLowerCase();\n}\nexport function deepClone(target) {\n  return JSON.parse(JSON.stringify(target));\n}\n")])])]),a("p",[e._v("项目中只使用了 targetType 方法，但未使用 deepClone 方法，项目打包后，deepClone 方法不会被打包到项目里")]),e._v(" "),a("p",[e._v("tree-shaking 原理：")]),e._v(" "),a("p",[e._v("依赖于 ES6 的模块特性，ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础")]),e._v(" "),a("p",[e._v("静态分析就是不需要执行代码，就可以从字面量上对代码进行分析。ES6 之前的模块化，比如 CommonJS 是动态加载，只有执行后才知道引用的什么模块，就不能通过静态分析去做优化，正是基于这个基础上，才使得 tree-shaking 成为可能")]),e._v(" "),a("h3",{attrs:{id:"tree-shaking-并不是万能的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking-并不是万能的"}},[e._v("#")]),e._v(" Tree shaking 并不是万能的")]),e._v(" "),a("p",[e._v("并不是说所有无用的代码都可以被消除，还是上面的代码，换个写法 tree-shaking 就失效了")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// util.js\nexport default {\n  targetType(target) {\n    return Object.prototype.toString.call(target).slice(8, -1).toLowerCase();\n  },\n  deepClone(target) {\n    return JSON.parse(JSON.stringify(target));\n  }\n};\n\n// 引入并使用\nimport util from '../util';\nutil.targetType(null)\n")])])]),a("p",[e._v("同样的，项目中只使用了 targetType 方法，未使用 deepClone 方法，项目打包后，deepClone 方法还是被打包到项目里")]),e._v(" "),a("p",[e._v("在 dist 文件中搜索 deepClone 方法：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0vRicmJ3iaWoYHfSJHeO1yfq2ZHydpbLFRHLGL89YuJcUJqAIEtM4KC4Q/640?",alt:"图片"}})]),e._v(" "),a("p",[e._v("究其原因，export default 导出的是一个对象，"),a("strong",[e._v("「无法通过静态分析判断出一个对象的哪些变量未被使用，所以 tree-shaking 只对使用 export 导出的变量生效」")])]),e._v(" "),a("p",[e._v("这也是函数式编程越来越火的原因，因为可以很好利用 tree-shaking 精简项目的体积，也是 vue3 全面拥抱了函数式编程的原因之一")]),e._v(" "),a("h2",{attrs:{id:"_4、骨架屏优化白屏时长"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、骨架屏优化白屏时长"}},[e._v("#")]),e._v(" 4、骨架屏优化白屏时长")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0Erqib5Em9dZyWL4ZZwmNt9UKbJ0xiaFic36SuSoSaiboFbfkoaqsY7fjYA/640?",alt:"图片"}})]),e._v(" "),a("p",[e._v("使用骨架屏，可以缩短白屏时间，提升用户体验。国内大多数的主流网站都使用了骨架屏，特别是手机端的项目")]),e._v(" "),a("p",[e._v("SPA 单页应用，无论 vue 还是 react，最初的 html 都是空白的，需要通过加载 JS 将内容挂载到根节点上，这套机制的副作用：会造成长时间的白屏")]),e._v(" "),a("p",[e._v("常见的骨架屏插件就是基于这种原理，在项目打包时将骨架屏的内容直接放到 html 文件的根节点中")]),e._v(" "),a("p",[e._v("使用骨架屏插件，打包后的 html 文件（根节点内部为骨架屏）：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU05eoiag1EQO7ibCDaqZthNyyHP2oeVNLPjBmcEPO8AxRJ6ToRkJ8If5qQ/640?",alt:"图片"}})]),e._v(" "),a("p",[e._v("同一项目，对比使用骨架屏前后的 FP 白屏时间：")]),e._v(" "),a("ul",[a("li",[e._v("无骨架屏：白屏时间 "),a("code",[e._v("1063ms")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0Nt4GkqQZ0LpiaSb4ALv377M6JLCJDVLwib5CZsn6jq9VtFPk9s193u6w/640?",alt:"图片"}})]),e._v(" "),a("ul",[a("li",[e._v("有骨架屏：白屏时间 "),a("code",[e._v("144ms")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0RibwJKsZNVviaibYC3LNMzGTGcqI9JB0HOQG3V74qbuwiaAzj5USzHAolA/640?",alt:"图片"}})]),e._v(" "),a("p",[e._v("骨架屏确实是优化白屏的不二选择，白屏时间缩短了 "),a("code",[e._v("86%")])]),e._v(" "),a("h3",{attrs:{id:"骨架屏插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#骨架屏插件"}},[e._v("#")]),e._v(" 骨架屏插件")]),e._v(" "),a("p",[e._v("这里以 "),a("code",[e._v("vue-skeleton-webpack-plugin")]),e._v(" 插件为例，该插件的亮点是可以给不同的页面设置不同的骨架屏，这点确实很酷")]),e._v(" "),a("p",[e._v("1）安装")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("npm i vue-skeleton-webpack-plugin\n")])])]),a("p",[e._v("2）vue.config.js 配置")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 骨架屏\nconst SkeletonWebpackPlugin = require(\"vue-skeleton-webpack-plugin\");\nmodule.exports = {\n   configureWebpack: {\n      plugins: [\n       new SkeletonWebpackPlugin({\n        // 实例化插件对象\n        webpackConfig: {\n          entry: {\n            app: path.join(__dirname, './src/skeleton.js') // 引入骨架屏入口文件\n          }\n        },\n        minimize: true, // SPA 下是否需要压缩注入 HTML 的 JS 代码\n        quiet: true, // 在服务端渲染时是否需要输出信息到控制台\n        router: {\n          mode: 'hash', // 路由模式\n          routes: [\n            // 不同页面可以配置不同骨架屏\n            // 对应路径所需要的骨架屏组件id，id的定义在入口文件内\n            { path: /^\\/home(?:\\/)?/i, skeletonId: 'homeSkeleton' },\n            { path: /^\\/detail(?:\\/)?/i, skeletonId: 'detailSkeleton' }\n          ]\n        }\n      })\n      ]\n   }\n}\n")])])]),a("p",[e._v("3）新建 skeleton.js 入口文件")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// skeleton.js\nimport Vue from "vue";\n// 引入对应的骨架屏页面\nimport homeSkeleton from "./views/homeSkeleton";\nimport detailSkeleton from "./views/detailSkeleton";\n\nexport default new Vue({\n    components: {\n        homeSkeleton,\n        detailSkeleton,\n    },\n    template: `\n    <div>\n      <homeSkeleton id="homeSkeleton" style="display:none;" />\n      <detailSkeleton id="detailSkeleton" style="display:none;" />\n    </div>\n  `,\n});\n')])])]),a("h2",{attrs:{id:"_5、长列表虚拟滚动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、长列表虚拟滚动"}},[e._v("#")]),e._v(" 5、长列表虚拟滚动")]),e._v(" "),a("p",[e._v("首页中不乏有需要渲染长列表的场景，当渲染条数过多时，所需要的渲染时间会很长，滚动时还会造成页面卡顿，整体体验非常不好")]),e._v(" "),a("p",[e._v("**「虚拟滚动——指的是只渲染可视区域的列表项，非可见区域的」**不渲染，在滚动时动态更新可视区域，该方案在优化大量数据渲染时效果是很明显的")]),e._v(" "),a("p",[e._v("虚拟滚动图例：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0D9vXA2SgSdFSOwX7b1EBxpiax74Po2upibGWJnRbZx5lHKSh1t134PlQ/640?",alt:"图片"}})]),e._v(" "),a("p",[e._v("虚拟滚动基本原理：")]),e._v(" "),a("p",[e._v("计算出 totalHeight 列表总高度，并在触发时滚动事件时根据 scrollTop 值不断更新 startIndex 以及 endIndex ，以此从列表数据 listData 中截取对应元素")]),e._v(" "),a("p",[e._v("虚拟滚动性能对比：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("在不使用虚拟滚动的情况下，渲染 10 万个文本节点：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0ics7OAmaich1qwNEUG6SfLIjP8iaa8sOIQr3ibGMsXVMuib3LaFfRcQngUA/640?",alt:"图片"}})])]),e._v(" "),a("li",[a("p",[e._v("使用虚拟滚动的情况后：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0ROnTTFvDVK4RDJGCAI06o4NhwsTkQ0IjdIkdTpZqegib3wAmrNibyiasQ/640?",alt:"图片"}})])])]),e._v(" "),a("p",[e._v("使用虚拟滚动使性能提升了 "),a("code",[e._v("78%")])]),e._v(" "),a("h3",{attrs:{id:"虚拟滚动插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟滚动插件"}},[e._v("#")]),e._v(" 虚拟滚动插件")]),e._v(" "),a("p",[e._v("虚拟滚动的插件有很多，比如 vue-virtual-scroller、vue-virtual-scroll-list、react-tiny-virtual-list、react-virtualized 等")]),e._v(" "),a("p",[e._v("这里简单介绍 "),a("strong",[e._v("vue-virtual-scroller")]),e._v(" 的使用")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// 安装插件\nnpm install vue-virtual-scroller\n\n// main.js\nimport VueVirtualScroller from \'vue-virtual-scroller\'\nimport \'vue-virtual-scroller/dist/vue-virtual-scroller.css\'\n\nVue.use(VueVirtualScroller)\n\n// 使用\n<template>\n  <RecycleScroller\n    class="scroller"\n    :items="list"\n    :item-size="32"\n    key-field="id"\n    v-slot="{ item }">\n      <div class="user"> {{ item.name }} </div>\n  </RecycleScroller>\n</template>\n')])])]),a("p",[e._v("该插件主要有 RecycleScroller.vue、DynamicScroller.vue 这两个组件，其中 RecycleScroller 需要 item 的高度为静态的，也就是列表每个 item 的高度都是一致的，而 DynamicScroller 可以兼容 item 的高度为动态的情况")]),e._v(" "),a("h2",{attrs:{id:"_6、web-worker-优化长任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、web-worker-优化长任务"}},[e._v("#")]),e._v(" 6、Web Worker 优化长任务")]),e._v(" "),a("p",[e._v("由于浏览器 GUI 渲染线程与 JS 引擎线程是互斥的关系，当页面中有很多长任务时，会造成页面 UI 阻塞，出现界面卡顿、掉帧等情况")]),e._v(" "),a("p",[e._v("查看页面的长任务：")]),e._v(" "),a("p",[e._v("打开控制台，选择 Performance 工具，点击 Start 按钮，展开 Main 选项，会发现有很多红色的三角，这些就属于长任务（长任务：执行时间超过 50ms 的任务）")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0qqAf7Dwl71Gs42cibOJ8iaCuvD369QQBUrHxicUPwB353kJjaIH7L0esw/640?",alt:"图片"}})]),e._v(" "),a("p",[e._v("测试实验：")]),e._v(" "),a("p",[e._v("如果直接把下面这段代码直接丢到主线程中，计算过程中页面一直处于卡死状态，无法操作")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let sum = 0;\nfor (let i = 0; i < 200000; i++) {\n    for (let i = 0; i < 10000; i++) {\n      sum += Math.random()\n    }\n  }\n")])])]),a("p",[e._v("使用 Web Worker 执行上述代码时，计算过程中页面正常可操作、无卡顿")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// worker.js\nonmessage = function (e) {\n  // onmessage获取传入的初始值\n  let sum = e.data;\n  for (let i = 0; i < 200000; i++) {\n    for (let i = 0; i < 10000; i++) {\n      sum += Math.random()\n    }\n  }\n  // 将计算的结果传递出去\n  postMessage(sum);\n}\n")])])]),a("p",[e._v("Web Worker 具体的使用与案例，详情见 "),a("strong",[e._v("一文彻底了解 Web Worker，十万、百万条数据都是弟弟 🔥")])]),e._v(" "),a("h3",{attrs:{id:"web-worker-的通信时长"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-worker-的通信时长"}},[e._v("#")]),e._v(" Web Worker 的通信时长")]),e._v(" "),a("p",[e._v("并不是执行时间超过 50ms 的任务，就可以使用 Web Worker，还要先考虑"),a("code",[e._v("通信时长")]),e._v("的问题")]),e._v(" "),a("p",[e._v("假如一个运算执行时长为 100ms，但是通信时长为 300ms， 用了 Web Worker 可能会更慢")]),e._v(" "),a("p",[e._v("比如新建一个 web worker, 浏览器会加载对应的 worker.js 资源，下图中的 Time 是这个资源的通信时长（也叫加载时长）")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU046RMbyicGhu0QzOZia5qLv73JOxxg8LUb5JYeghjBL3AcoS9hoibdKNew/640?",alt:"图片"}})]),e._v(" "),a("p",[a("strong",[e._v("「当任务的运算时长 - 通信时长 > 50ms，推荐使用 Web Worker」")])]),e._v(" "),a("h2",{attrs:{id:"_7、requestanimationframe-制作动画"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、requestanimationframe-制作动画"}},[e._v("#")]),e._v(" 7、requestAnimationFrame 制作动画")]),e._v(" "),a("p",[a("code",[e._v("requestAnimationFrame")]),e._v(" 是浏览器专门为动画提供的 API，它的刷新频率与显示器的频率保持一致，使用该 api 可以解决用 setTimeout/setInterval 制作动画卡顿的情况")]),e._v(" "),a("p",[e._v("1）引擎层面")]),e._v(" "),a("p",[e._v("setTimeout/setInterval 属于 "),a("code",[e._v("JS引擎")]),e._v("，requestAnimationFrame 属于 "),a("code",[e._v("GUI引擎")])]),e._v(" "),a("p",[a("code",[e._v("JS引擎与GUI引擎")]),e._v("是互斥的，也就是说 GUI 引擎在渲染时会阻塞 JS 引擎的计算")]),e._v(" "),a("p",[e._v("2）时间是否准确")]),e._v(" "),a("p",[e._v("requestAnimationFrame 刷新频率是固定且准确的，但 setTimeout/setInterval 是宏任务，根据事件轮询机制，其他任务会阻塞或延迟 js 任务的执行，会出现定时器不准的情况")]),e._v(" "),a("p",[e._v("3）性能层面")]),e._v(" "),a("p",[e._v("当页面被隐藏或最小化时，setTimeout/setInterval 定时器仍会在后台执行动画任务，而使用 requestAnimationFrame 当页面处于未激活的状态下，屏幕刷新任务会被系统暂停")]),e._v(" "),a("h2",{attrs:{id:"_8、js-的-6-种加载方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8、js-的-6-种加载方式"}},[e._v("#")]),e._v(" 8、JS 的 6 种加载方式")]),e._v(" "),a("h3",{attrs:{id:"_1-正常模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-正常模式"}},[e._v("#")]),e._v(" 1）正常模式")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<script src="index.js"><\/script>\n')])])]),a("p",[e._v("这种情况下 JS 会阻塞 dom 渲染，浏览器必须等待 index.js 加载和执行完成后才能去做其它事情")]),e._v(" "),a("h3",{attrs:{id:"_2-async-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-async-模式"}},[e._v("#")]),e._v(" 2）async 模式")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<script async src="index.js"><\/script>\n')])])]),a("p",[e._v("async 模式下，它的加载是异步的，JS 不会阻塞 DOM 的渲染，async 加载是无顺序的，当它加载结束，JS 会立即执行")]),e._v(" "),a("p",[e._v("使用场景：若该 JS 资源与 DOM 元素没有依赖关系，也不会产生其他资源所需要的数据时，可以使用 async 模式，比如埋点统计")]),e._v(" "),a("h3",{attrs:{id:"_3-defer-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-defer-模式"}},[e._v("#")]),e._v(" 3）defer 模式")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<script defer src="index.js"><\/script>\n')])])]),a("p",[e._v("defer 模式下，JS 的加载也是异步的，defer 资源会在  "),a("code",[e._v("DOMContentLoaded")]),e._v(" 执行之前，并且 defer 是有顺序的加载")]),e._v(" "),a("p",[e._v("如果有多个设置了 defer 的 script 标签存在，则会按照引入的前后顺序执行，即便是后面的 script 资源先返回")]),e._v(" "),a("p",[e._v("所以 defer 可以用来控制 JS 文件的执行顺序，比如 element-ui.js 和 vue.js，因为 element-ui.js 依赖于 vue，所以必须先引入 vue.js，再引入 element-ui.js")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<script defer src="vue.js"><\/script>\n<script defer src="element-ui.js"><\/script>\n')])])]),a("p",[e._v("defer 使用场景：一般情况下都可以使用 defer，特别是需要控制资源加载顺序时")]),e._v(" "),a("h3",{attrs:{id:"_4-module-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-module-模式"}},[e._v("#")]),e._v(" 4）module 模式")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<script type=\"module\">import { a } from './a.js'<\/script>\n")])])]),a("p",[e._v("在主流的现代浏览器中，script 标签的属性可以加上  "),a("code",[e._v('type="module"')]),e._v("，浏览器会对其内部的 import 引用发起 HTTP 请求，获取模块内容。这时 script 的行为会像是  defer 一样，在后台下载，并且等待 DOM 解析")]),e._v(" "),a("p",[e._v("Vite 就是利用浏览器支持原生的 "),a("code",[e._v("es module")]),e._v(" 模块，开发时跳过打包的过程，提升编译效率")]),e._v(" "),a("h3",{attrs:{id:"_5-preload"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-preload"}},[e._v("#")]),e._v(" 5） preload")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<link rel="preload" as="script" href="index.js">\n')])])]),a("p",[e._v("link 标签的 preload 属性：用于提前加载一些需要的依赖，这些资源会优先加载")]),e._v(" "),a("p",[e._v("vue2 项目打包生成的 index.html 文件，会自动给首页所需要的资源，全部添加 preload，实现关键资源的提前加载")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0EgHd0g3CmZvomcWbozaia2YIZry8WlJofrlSu4vy0d3S4CSq9NSHmcQ/640?",alt:"图片"}})]),e._v(" "),a("p",[e._v("preload 特点：")]),e._v(" "),a("p",[e._v("1）preload 加载的资源是在浏览器渲染机制之前进行处理的，并且不会阻塞 onload 事件；")]),e._v(" "),a("p",[e._v("2）preload 加载的 JS 脚本其加载和执行的过程是分离的，即 preload 会预加载相应的脚本代码，待到需要时自行调用；")]),e._v(" "),a("h3",{attrs:{id:"_6-prefetch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-prefetch"}},[e._v("#")]),e._v(" 6）prefetch")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<link rel="prefetch" as="script" href="index.js">\n')])])]),a("p",[e._v("prefetch 是利用浏览器的空闲时间，加载页面将来可能用到的资源的一种机制；通常可以用于加载其他页面（非首页）所需要的资源，以便加快后续页面的打开速度")]),e._v(" "),a("p",[e._v("prefetch 特点：")]),e._v(" "),a("p",[e._v("1）pretch 加载的资源可以获取非当前页面所需要的资源，并且将其放入缓存至少 5 分钟（无论资源是否可以缓存）")]),e._v(" "),a("p",[e._v("2）当页面跳转时，未完成的 prefetch 请求不会被中断")]),e._v(" "),a("h3",{attrs:{id:"加载方式总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加载方式总结"}},[e._v("#")]),e._v(" 加载方式总结")]),e._v(" "),a("p",[e._v("async、defer 是  script 标签的专属属性，对于网页中的其他资源，可以通过  link 的 preload、prefetch 属性来预加载")]),e._v(" "),a("p",[e._v("如今现代框架已经将 preload、prefetch 添加到打包流程中了，通过灵活的配置，去使用这些预加载功能，同时我们也可以审时度势地向 script 标签添加 async、defer 属性去处理资源，这样可以显著提升性能")]),e._v(" "),a("h2",{attrs:{id:"_9、图片的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9、图片的优化"}},[e._v("#")]),e._v(" 9、图片的优化")]),e._v(" "),a("p",[e._v("平常大部分性能优化工作都集中在 JS 方面，但图片也是页面上非常重要的部分")]),e._v(" "),a("p",[e._v("特别是对于移动端来说，完全没有必要去加载原图，浪费带宽。如何去压缩图片，让图片更快的展示出来，有很多优化工作可以做")]),e._v(" "),a("p",[e._v("淘宝首页的图片资源都很小：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0bNfkj3c6EXp34ibNlI0qNyOFG5SvR2g2YaBXphEE69iaaHnRiapupR2tQ/640?",alt:"图片"}})]),e._v(" "),a("h3",{attrs:{id:"图片的动态裁剪"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图片的动态裁剪"}},[e._v("#")]),e._v(" 图片的动态裁剪")]),e._v(" "),a("p",[e._v("很多云服务，比如"),a("strong",[e._v("阿里云")]),e._v("或"),a("strong",[e._v("七牛云")]),e._v("，都提供了图片的动态裁剪功能，效果很棒，确实是钱没有白花")]),e._v(" "),a("p",[e._v("只需在图片的 url 地址上动态添加参数，就可以得到你所需要的尺寸大小，比如："),a("code",[e._v("http://7xkv1q.com1.z0.glb.clouddn.com/grape.jpg?imageView2/1/w/200/h/200")])]),e._v(" "),a("p",[e._v("图片瘦身前后对比：")]),e._v(" "),a("ul",[a("li",[e._v("原图："),a("code",[e._v("1.8M")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0dNKrFzDuIiaQAPfbHMuUS04YibVZVqffuNREN9VticstBkcZLWkRYBKqQ/640?",alt:"图片"}})]),e._v(" "),a("ul",[a("li",[e._v("裁剪后："),a("code",[e._v("12.8KB")])])]),e._v(" "),a("p",[e._v("经过动态裁剪后的图片，加载速度会有非常明显的提升")]),e._v(" "),a("h3",{attrs:{id:"图片的懒加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图片的懒加载"}},[e._v("#")]),e._v(" 图片的懒加载")]),e._v(" "),a("p",[e._v("对于一些图片量比较大的首页，用户打开页面后，只需要呈现出在屏幕可视区域内的图片，当用户滑动页面时，再去加载出现在屏幕内的图片，以优化图片的加载效果")]),e._v(" "),a("p",[e._v("图片懒加载实现原理：")]),e._v(" "),a("p",[e._v("由于浏览器会自动对页面中的 img 标签的 src 属性发送请求并下载图片，可以通过 html5 自定义属性 data-xxx 先暂存 src 的值，然后在图片出现在屏幕可视区域的时候，再将 data-xxx 的值重新赋值到 img 的 src 属性即可")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<img src="" alt="" data-src="./images/1.jpg">\n<img src="" alt="" data-src="./images/2.jpg">\n')])])]),a("p",[e._v("这里以 "),a("code",[e._v("vue-lazyload")]),e._v(" 插件为例")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 安装\nnpm install vue-lazyload\n\n// main.js 注册\nimport VueLazyload from 'vue-lazyload'\nVue.use(VueLazyload)\n// 配置项\nVue.use(VueLazyload, {\n  preLoad: 1.3,\n  error: 'dist/error.png', // 图片加载失败时的占位图\n  loading: 'dist/loading.gif', // 图片加载中时的占位图\n  attempt: 1\n})\n\n// 通过 v-lazy 指令使用\n<ul>\n    <li v-for=\"img in list\">\n        <img v-lazy=\"img.src\" :key=\"img.src\" >\n    </li>\n</ul>\n")])])]),a("h3",{attrs:{id:"使用字体图标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用字体图标"}},[e._v("#")]),e._v(" 使用字体图标")]),e._v(" "),a("p",[e._v("字体图标是页面使用小图标的不二选择，最常用的就是 "),a("strong",[e._v("iconfont")])]),e._v(" "),a("p",[e._v("字体图标的优点：")]),e._v(" "),a("p",[e._v("1）轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了 http 请求")]),e._v(" "),a("p",[e._v("2）灵活性：可以随意的改变颜色、产生阴影、透明效果、旋转等")]),e._v(" "),a("p",[e._v("3）兼容性：几乎支持所有的浏览器，请放心使用")]),e._v(" "),a("h3",{attrs:{id:"图片转-base64-格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图片转-base64-格式"}},[e._v("#")]),e._v(" 图片转 base64 格式")]),e._v(" "),a("p",[e._v("将小图片转换为 base64 编码字符串，并写入 HTML 或者 CSS 中，减少 http 请求")]),e._v(" "),a("p",[e._v("转 base64 格式的优缺点：")]),e._v(" "),a("p",[e._v("1）它处理的往往是非常小的图片，因为 Base64 编码后，图片大小会膨胀为原文件的 4/3，如果对大图也使用 Base64 编码，后者的体积会明显增加，即便减少了 http 请求，也无法弥补这庞大的体积带来的性能开销，得不偿失")]),e._v(" "),a("p",[e._v("2）在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 http 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势")]),e._v(" "),a("p",[e._v("项目可以使用 "),a("code",[e._v("url-loader")]),e._v(" 将图片转 base64：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 安装\nnpm install url-loader --save-dev\n\n// 配置\nmodule.exports = {\n  module: {\n    rules: [{\n        test: /.(png|jpg|gif)$/i,\n        use: [{\n            loader: 'url-loader',\n            options: {\n              // 小于 10kb 的图片转化为 base64\n              limit: 1024 * 10\n            }\n        }]\n     }]\n  }\n};\n")])])]),a("h2",{attrs:{id:"优化总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化总结"}},[e._v("#")]),e._v(" 优化总结")]),e._v(" "),a("p",[e._v("本文主要介绍的是 "),a("strong",[e._v("「代码层面」")]),e._v(" 的性能优化，经过上面的一系列优化，首页打开速度有了明显的提升，虽然都是一些常规方案，但其中可以深挖的知识点并不少")])])}),[],!1,null,null,null);t.default=r.exports}}]);