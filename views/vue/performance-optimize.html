<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>性能优化 | 杨欣的前端杂记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/yx_blog/imgs/logo.jpg">
    <meta name="description" content="欢迎来到杨欣的前端杂记">
    
    <link rel="preload" href="/yx_blog/assets/css/0.styles.9025f1a7.css" as="style"><link rel="preload" href="/yx_blog/assets/js/app.e0a8f1e5.js" as="script"><link rel="preload" href="/yx_blog/assets/js/2.95e582b3.js" as="script"><link rel="preload" href="/yx_blog/assets/js/29.5ca16a60.js" as="script"><link rel="prefetch" href="/yx_blog/assets/js/10.852a3690.js"><link rel="prefetch" href="/yx_blog/assets/js/11.b7d25596.js"><link rel="prefetch" href="/yx_blog/assets/js/12.82266757.js"><link rel="prefetch" href="/yx_blog/assets/js/13.cf1e77f3.js"><link rel="prefetch" href="/yx_blog/assets/js/14.a9e47a7f.js"><link rel="prefetch" href="/yx_blog/assets/js/15.1384f59f.js"><link rel="prefetch" href="/yx_blog/assets/js/16.d5b91b94.js"><link rel="prefetch" href="/yx_blog/assets/js/17.6cab991f.js"><link rel="prefetch" href="/yx_blog/assets/js/18.00aec882.js"><link rel="prefetch" href="/yx_blog/assets/js/19.34034c9c.js"><link rel="prefetch" href="/yx_blog/assets/js/20.8841c49e.js"><link rel="prefetch" href="/yx_blog/assets/js/21.aca8d043.js"><link rel="prefetch" href="/yx_blog/assets/js/22.c40a0d9c.js"><link rel="prefetch" href="/yx_blog/assets/js/23.b24afd47.js"><link rel="prefetch" href="/yx_blog/assets/js/24.be84b6e7.js"><link rel="prefetch" href="/yx_blog/assets/js/25.77357fc0.js"><link rel="prefetch" href="/yx_blog/assets/js/26.8a3d42fc.js"><link rel="prefetch" href="/yx_blog/assets/js/27.70f0fe8a.js"><link rel="prefetch" href="/yx_blog/assets/js/28.c5cf210b.js"><link rel="prefetch" href="/yx_blog/assets/js/3.5b12ee6f.js"><link rel="prefetch" href="/yx_blog/assets/js/30.fb1f60c1.js"><link rel="prefetch" href="/yx_blog/assets/js/31.2fbe73e3.js"><link rel="prefetch" href="/yx_blog/assets/js/32.b4d61232.js"><link rel="prefetch" href="/yx_blog/assets/js/33.c87924c5.js"><link rel="prefetch" href="/yx_blog/assets/js/34.70dcd269.js"><link rel="prefetch" href="/yx_blog/assets/js/35.633fb91f.js"><link rel="prefetch" href="/yx_blog/assets/js/4.02bdbb3c.js"><link rel="prefetch" href="/yx_blog/assets/js/5.ce292cd4.js"><link rel="prefetch" href="/yx_blog/assets/js/6.5a41d7cc.js"><link rel="prefetch" href="/yx_blog/assets/js/7.0694149e.js"><link rel="prefetch" href="/yx_blog/assets/js/8.ba0d71a7.js"><link rel="prefetch" href="/yx_blog/assets/js/9.f0236701.js">
    <link rel="stylesheet" href="/yx_blog/assets/css/0.styles.9025f1a7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/yx_blog/" class="home-link router-link-active"><img src="/yx_blog/imgs/logo.jpg" alt="杨欣的前端杂记" class="logo"> <span class="site-name can-hide">杨欣的前端杂记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/yx_blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/yx_blog/vue/" class="nav-link">
  vue及周边
</a></div><div class="nav-item"><a href="/yx_blog/about/" class="nav-link">
  关于我
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="好友链接" class="dropdown-title"><span class="title">好友链接</span> <span class="arrow down"></span></button> <button type="button" aria-label="好友链接" class="mobile-dropdown-title"><span class="title">好友链接</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://zhuijing.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  曹泽鹏的笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://shikkk.github.io/file/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  石志凯的技术杂货铺
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://zhangjy1994.github.io/webnotes/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  张佳宇的笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/yx_blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/yx_blog/vue/" class="nav-link">
  vue及周边
</a></div><div class="nav-item"><a href="/yx_blog/about/" class="nav-link">
  关于我
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="好友链接" class="dropdown-title"><span class="title">好友链接</span> <span class="arrow down"></span></button> <button type="button" aria-label="好友链接" class="mobile-dropdown-title"><span class="title">好友链接</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://zhuijing.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  曹泽鹏的笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://shikkk.github.io/file/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  石志凯的技术杂货铺
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://zhangjy1994.github.io/webnotes/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  张佳宇的笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/yx_blog/interview/" class="sidebar-heading clickable"><span>前言</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/yx_blog/interview.html" class="sidebar-link">创建博客目的</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Interview</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Html</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/yx_blog/views/vue/base.html" class="sidebar-link">vue2.x</a></li><li><a href="/yx_blog/views/vue/vuex.html" class="sidebar-link">Vuex</a></li><li><a href="/yx_blog/views/vue/optimazition.html" class="sidebar-link">vue项目优化</a></li><li><a href="/yx_blog/views/vue/performance-optimize.html" aria-current="page" class="active sidebar-link">性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yx_blog/views/vue/performance-optimize.html#性能优化" class="sidebar-link">性能优化</a></li><li class="sidebar-sub-header"><a href="/yx_blog/views/vue/performance-optimize.html#_1、路由懒加载" class="sidebar-link">1、路由懒加载</a></li><li class="sidebar-sub-header"><a href="/yx_blog/views/vue/performance-optimize.html#_2、组件懒加载" class="sidebar-link">2、组件懒加载</a></li><li class="sidebar-sub-header"><a href="/yx_blog/views/vue/performance-optimize.html#_3、合理使用-tree-shaking" class="sidebar-link">3、合理使用 Tree shaking</a></li><li class="sidebar-sub-header"><a href="/yx_blog/views/vue/performance-optimize.html#_4、骨架屏优化白屏时长" class="sidebar-link">4、骨架屏优化白屏时长</a></li><li class="sidebar-sub-header"><a href="/yx_blog/views/vue/performance-optimize.html#_5、长列表虚拟滚动" class="sidebar-link">5、长列表虚拟滚动</a></li><li class="sidebar-sub-header"><a href="/yx_blog/views/vue/performance-optimize.html#_6、web-worker-优化长任务" class="sidebar-link">6、Web Worker 优化长任务</a></li><li class="sidebar-sub-header"><a href="/yx_blog/views/vue/performance-optimize.html#_7、requestanimationframe-制作动画" class="sidebar-link">7、requestAnimationFrame 制作动画</a></li><li class="sidebar-sub-header"><a href="/yx_blog/views/vue/performance-optimize.html#_8、js-的-6-种加载方式" class="sidebar-link">8、JS 的 6 种加载方式</a></li><li class="sidebar-sub-header"><a href="/yx_blog/views/vue/performance-optimize.html#_9、图片的优化" class="sidebar-link">9、图片的优化</a></li><li class="sidebar-sub-header"><a href="/yx_blog/views/vue/performance-optimize.html#优化总结" class="sidebar-link">优化总结</a></li></ul></li><li><a href="/yx_blog/views/vue/vue3.html" class="sidebar-link">Vue3</a></li><li><a href="/yx_blog/views/vue/vuekey.html" class="sidebar-link">为什么 Vue 中不要用 index 作为 key？（diff 算法详解）</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器&amp;Http</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h2> <p>提升首屏的加载速度，是前端性能优化中**「最重要」**的环节，这里笔者梳理出一些 <code>常规且有效</code> 的首屏优化建议</p> <p><strong>「目标：」</strong> 通过对比优化前后的性能变化，来验证方案的有效性，了解并掌握其原理</p> <h2 id="_1、路由懒加载"><a href="#_1、路由懒加载" class="header-anchor">#</a> 1、路由懒加载</h2> <p>SPA 项目，一个路由对应一个页面，如果不做处理，项目打包后，会把所有页面打包成一个文件，<strong>「当用户打开首页时，会一次性加载所有的资源」</strong>，造成首页加载很慢，降低用户体验</p> <p>列一个实际项目的打包详情：</p> <ul><li>app.js 初始体积： <code>1175 KB</code></li></ul> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0w9YPPRQhAUnDo0IXzQ1uYJdTyt5Kusu2ia5iaFjabbevibtUD3a9udIvw/640?" alt="图片"></p> <ul><li>app.css 初始体积：<code>274 KB</code></li></ul> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0vTh8yVWW54iavPBiards0xtNcLh7rEonzNdzZvaEchzFPkXQnAuGIbFA/640?" alt="图片"></p> <p>将路由全部改成懒加载</p> <div class="language- extra-class"><pre class="language-text"><code>// 通过webpackChunkName设置分割后代码块的名字
const Home = () =&gt; import(/* webpackChunkName: &quot;home&quot; */ &quot;@/views/home/index.vue&quot;);
const MetricGroup = () =&gt; import(/* webpackChunkName: &quot;metricGroup&quot; */ &quot;@/views/metricGroup/index.vue&quot;);
…………
const routes = [
    {
       path: &quot;/&quot;,
       name: &quot;home&quot;,
       component: Home
    },
    {
       path: &quot;/metricGroup&quot;,
       name: &quot;metricGroup&quot;,
       component: MetricGroup
    },
    …………
 ]
</code></pre></div><p>重新打包后，首页资源拆分为 app.js 和 home.js，以及对应的 css 文件</p> <ul><li>app.js：<code>244 KB</code>、 home.js: <code>35KB</code></li></ul> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0xnicvqUvBTGhLib9WfEWliaTnrP7hqqBcXob5P1EibnBC43pg4aSXSibichw/640?" alt="图片"></p> <ul><li>app.css：<code>67 KB</code>、home.css: <code>15KB</code></li></ul> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0WkHxTxxkFasPo79BMHLpjPnMWtDiavS4n8g6WFuVnkqkIKPEKDn7y6w/640?" alt="图片"></p> <p>通过路由懒加载，该项目的首页资源压缩约 <code>52%</code></p> <h3 id="路由懒加载的原理"><a href="#路由懒加载的原理" class="header-anchor">#</a> 路由懒加载的原理</h3> <p>懒加载前提的实现：ES6 的动态地加载模块——<code>import()</code></p> <blockquote><p>调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中
——摘自**《webpack——模块方法》的 import()小节**</p></blockquote> <p>要实现懒加载，就得先将进行懒加载的子模块分离出来，打包成一个单独的文件</p> <p>webpackChunkName 作用是 webpack 在打包的时候，对异步引入的库代码（lodash）进行代码分割时，设置代码块的名字。webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中</p> <h2 id="_2、组件懒加载"><a href="#_2、组件懒加载" class="header-anchor">#</a> 2、组件懒加载</h2> <p>除了路由的懒加载外，组件的懒加载在很多场景下也有重要的作用</p> <p>举个 🌰：</p> <p>home 页面 和 about 页面，都引入了 dialogInfo 弹框组件，该弹框不是一进入页面就加载，而是需要用户手动触发后才展示出来</p> <p>home 页面示例：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;template&gt;
  &lt;div class=&quot;homeView&quot;&gt;
    &lt;p&gt;home 页面&lt;/p&gt;
    &lt;el-button @click=&quot;dialogVisible = !dialogVisible&quot;&gt;打开弹框&lt;/el-button&gt;
    &lt;dialogInfo v-if=&quot;dialogVisible&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import dialogInfo from '@/components/dialogInfo';
export default {
  name: 'homeView',
  components: {
    dialogInfo
  }
}
&lt;/script&gt;
</code></pre></div><p>项目打包后，发现 home.js 和 about.js 均包括了该弹框组件的代码（在 dist 文件中搜索 dialogInfo 弹框组件）</p> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0eZiaZtWiclk852us2aD5URWoqwbnwibYY5K9bzcywkplQyeeDMu48bn4Q/640?" alt="图片"></p> <p>当用户打开 home 页时，会一次性加载该页面所有的资源，<strong>「我们期望的是用户触发按钮后，再加载该弹框组件的资源」</strong></p> <p>这种场景下，就很适合用懒加载的方式引入</p> <p>弹框组件懒加载：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
const dialogInfo = () =&gt; import(/* webpackChunkName: &quot;dialogInfo&quot; */ '@/components/dialogInfo');
export default {
  name: 'homeView',
  components: {
    dialogInfo
  }
}
&lt;/script&gt;
</code></pre></div><p>重新打包后，home.js 和 about.js 中没有了弹框组件的代码，该组件被独立打包成 dialogInfo.js，<strong>「当用户点击按钮时，才会去加载 dialogInfo.js 和 dialogInfo.css」</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0icWVHLrvltYPOeGCW3TDYiaxrgX3JCBOl9dUcOvqq8licRNbHX0eyZp2A/640?" alt="图片"></p> <p>最终，使用组件路由懒后，该项目的首页资源进一步减少约 <code>11%</code></p> <h3 id="组件懒加载的使用场景"><a href="#组件懒加载的使用场景" class="header-anchor">#</a> 组件懒加载的使用场景</h3> <p>有时资源拆分的过细也不好，可能会造成浏览器 http 请求的增多</p> <p>总结出三种适合组件懒加载的场景：</p> <p>1）该页面的 JS 文件体积大，导致页面打开慢，可以通过组件懒加载进行资源拆分，利用浏览器并行下载资源，提升下载速度（比如首页）</p> <p>2）该组件不是一进入页面就展示，需要一定条件下才触发（比如弹框组件）</p> <p>3）该组件复用性高，很多页面都有引入，利用组件懒加载抽离出该组件，一方面可以很好利用缓存，同时也可以减少页面的 JS 文件大小（比如表格组件、图形组件等）</p> <h2 id="_3、合理使用-tree-shaking"><a href="#_3、合理使用-tree-shaking" class="header-anchor">#</a> 3、合理使用 Tree shaking</h2> <p>Tree shaking 的作用：消除无用的 JS 代码，减少代码体积</p> <p>举个 🌰：</p> <div class="language- extra-class"><pre class="language-text"><code>// util.js
export function targetType(target) {
  return Object.prototype.toString.call(target).slice(8, -1).toLowerCase();
}
export function deepClone(target) {
  return JSON.parse(JSON.stringify(target));
}
</code></pre></div><p>项目中只使用了 targetType 方法，但未使用 deepClone 方法，项目打包后，deepClone 方法不会被打包到项目里</p> <p>tree-shaking 原理：</p> <p>依赖于 ES6 的模块特性，ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础</p> <p>静态分析就是不需要执行代码，就可以从字面量上对代码进行分析。ES6 之前的模块化，比如 CommonJS 是动态加载，只有执行后才知道引用的什么模块，就不能通过静态分析去做优化，正是基于这个基础上，才使得 tree-shaking 成为可能</p> <h3 id="tree-shaking-并不是万能的"><a href="#tree-shaking-并不是万能的" class="header-anchor">#</a> Tree shaking 并不是万能的</h3> <p>并不是说所有无用的代码都可以被消除，还是上面的代码，换个写法 tree-shaking 就失效了</p> <div class="language- extra-class"><pre class="language-text"><code>// util.js
export default {
  targetType(target) {
    return Object.prototype.toString.call(target).slice(8, -1).toLowerCase();
  },
  deepClone(target) {
    return JSON.parse(JSON.stringify(target));
  }
};

// 引入并使用
import util from '../util';
util.targetType(null)
</code></pre></div><p>同样的，项目中只使用了 targetType 方法，未使用 deepClone 方法，项目打包后，deepClone 方法还是被打包到项目里</p> <p>在 dist 文件中搜索 deepClone 方法：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0vRicmJ3iaWoYHfSJHeO1yfq2ZHydpbLFRHLGL89YuJcUJqAIEtM4KC4Q/640?" alt="图片"></p> <p>究其原因，export default 导出的是一个对象，<strong>「无法通过静态分析判断出一个对象的哪些变量未被使用，所以 tree-shaking 只对使用 export 导出的变量生效」</strong></p> <p>这也是函数式编程越来越火的原因，因为可以很好利用 tree-shaking 精简项目的体积，也是 vue3 全面拥抱了函数式编程的原因之一</p> <h2 id="_4、骨架屏优化白屏时长"><a href="#_4、骨架屏优化白屏时长" class="header-anchor">#</a> 4、骨架屏优化白屏时长</h2> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0Erqib5Em9dZyWL4ZZwmNt9UKbJ0xiaFic36SuSoSaiboFbfkoaqsY7fjYA/640?" alt="图片"></p> <p>使用骨架屏，可以缩短白屏时间，提升用户体验。国内大多数的主流网站都使用了骨架屏，特别是手机端的项目</p> <p>SPA 单页应用，无论 vue 还是 react，最初的 html 都是空白的，需要通过加载 JS 将内容挂载到根节点上，这套机制的副作用：会造成长时间的白屏</p> <p>常见的骨架屏插件就是基于这种原理，在项目打包时将骨架屏的内容直接放到 html 文件的根节点中</p> <p>使用骨架屏插件，打包后的 html 文件（根节点内部为骨架屏）：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU05eoiag1EQO7ibCDaqZthNyyHP2oeVNLPjBmcEPO8AxRJ6ToRkJ8If5qQ/640?" alt="图片"></p> <p>同一项目，对比使用骨架屏前后的 FP 白屏时间：</p> <ul><li>无骨架屏：白屏时间 <code>1063ms</code></li></ul> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0Nt4GkqQZ0LpiaSb4ALv377M6JLCJDVLwib5CZsn6jq9VtFPk9s193u6w/640?" alt="图片"></p> <ul><li>有骨架屏：白屏时间 <code>144ms</code></li></ul> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0RibwJKsZNVviaibYC3LNMzGTGcqI9JB0HOQG3V74qbuwiaAzj5USzHAolA/640?" alt="图片"></p> <p>骨架屏确实是优化白屏的不二选择，白屏时间缩短了 <code>86%</code></p> <h3 id="骨架屏插件"><a href="#骨架屏插件" class="header-anchor">#</a> 骨架屏插件</h3> <p>这里以 <code>vue-skeleton-webpack-plugin</code> 插件为例，该插件的亮点是可以给不同的页面设置不同的骨架屏，这点确实很酷</p> <p>1）安装</p> <div class="language- extra-class"><pre class="language-text"><code>npm i vue-skeleton-webpack-plugin
</code></pre></div><p>2）vue.config.js 配置</p> <div class="language- extra-class"><pre class="language-text"><code>// 骨架屏
const SkeletonWebpackPlugin = require(&quot;vue-skeleton-webpack-plugin&quot;);
module.exports = {
   configureWebpack: {
      plugins: [
       new SkeletonWebpackPlugin({
        // 实例化插件对象
        webpackConfig: {
          entry: {
            app: path.join(__dirname, './src/skeleton.js') // 引入骨架屏入口文件
          }
        },
        minimize: true, // SPA 下是否需要压缩注入 HTML 的 JS 代码
        quiet: true, // 在服务端渲染时是否需要输出信息到控制台
        router: {
          mode: 'hash', // 路由模式
          routes: [
            // 不同页面可以配置不同骨架屏
            // 对应路径所需要的骨架屏组件id，id的定义在入口文件内
            { path: /^\/home(?:\/)?/i, skeletonId: 'homeSkeleton' },
            { path: /^\/detail(?:\/)?/i, skeletonId: 'detailSkeleton' }
          ]
        }
      })
      ]
   }
}
</code></pre></div><p>3）新建 skeleton.js 入口文件</p> <div class="language- extra-class"><pre class="language-text"><code>// skeleton.js
import Vue from &quot;vue&quot;;
// 引入对应的骨架屏页面
import homeSkeleton from &quot;./views/homeSkeleton&quot;;
import detailSkeleton from &quot;./views/detailSkeleton&quot;;

export default new Vue({
    components: {
        homeSkeleton,
        detailSkeleton,
    },
    template: `
    &lt;div&gt;
      &lt;homeSkeleton id=&quot;homeSkeleton&quot; style=&quot;display:none;&quot; /&gt;
      &lt;detailSkeleton id=&quot;detailSkeleton&quot; style=&quot;display:none;&quot; /&gt;
    &lt;/div&gt;
  `,
});
</code></pre></div><h2 id="_5、长列表虚拟滚动"><a href="#_5、长列表虚拟滚动" class="header-anchor">#</a> 5、长列表虚拟滚动</h2> <p>首页中不乏有需要渲染长列表的场景，当渲染条数过多时，所需要的渲染时间会很长，滚动时还会造成页面卡顿，整体体验非常不好</p> <p>**「虚拟滚动——指的是只渲染可视区域的列表项，非可见区域的」**不渲染，在滚动时动态更新可视区域，该方案在优化大量数据渲染时效果是很明显的</p> <p>虚拟滚动图例：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0D9vXA2SgSdFSOwX7b1EBxpiax74Po2upibGWJnRbZx5lHKSh1t134PlQ/640?" alt="图片"></p> <p>虚拟滚动基本原理：</p> <p>计算出 totalHeight 列表总高度，并在触发时滚动事件时根据 scrollTop 值不断更新 startIndex 以及 endIndex ，以此从列表数据 listData 中截取对应元素</p> <p>虚拟滚动性能对比：</p> <ul><li><p>在不使用虚拟滚动的情况下，渲染 10 万个文本节点：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0ics7OAmaich1qwNEUG6SfLIjP8iaa8sOIQr3ibGMsXVMuib3LaFfRcQngUA/640?" alt="图片"></p></li> <li><p>使用虚拟滚动的情况后：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0ROnTTFvDVK4RDJGCAI06o4NhwsTkQ0IjdIkdTpZqegib3wAmrNibyiasQ/640?" alt="图片"></p></li></ul> <p>使用虚拟滚动使性能提升了 <code>78%</code></p> <h3 id="虚拟滚动插件"><a href="#虚拟滚动插件" class="header-anchor">#</a> 虚拟滚动插件</h3> <p>虚拟滚动的插件有很多，比如 vue-virtual-scroller、vue-virtual-scroll-list、react-tiny-virtual-list、react-virtualized 等</p> <p>这里简单介绍 <strong>vue-virtual-scroller</strong> 的使用</p> <div class="language- extra-class"><pre class="language-text"><code>// 安装插件
npm install vue-virtual-scroller

// main.js
import VueVirtualScroller from 'vue-virtual-scroller'
import 'vue-virtual-scroller/dist/vue-virtual-scroller.css'

Vue.use(VueVirtualScroller)

// 使用
&lt;template&gt;
  &lt;RecycleScroller
    class=&quot;scroller&quot;
    :items=&quot;list&quot;
    :item-size=&quot;32&quot;
    key-field=&quot;id&quot;
    v-slot=&quot;{ item }&quot;&gt;
      &lt;div class=&quot;user&quot;&gt; {{ item.name }} &lt;/div&gt;
  &lt;/RecycleScroller&gt;
&lt;/template&gt;
</code></pre></div><p>该插件主要有 RecycleScroller.vue、DynamicScroller.vue 这两个组件，其中 RecycleScroller 需要 item 的高度为静态的，也就是列表每个 item 的高度都是一致的，而 DynamicScroller 可以兼容 item 的高度为动态的情况</p> <h2 id="_6、web-worker-优化长任务"><a href="#_6、web-worker-优化长任务" class="header-anchor">#</a> 6、Web Worker 优化长任务</h2> <p>由于浏览器 GUI 渲染线程与 JS 引擎线程是互斥的关系，当页面中有很多长任务时，会造成页面 UI 阻塞，出现界面卡顿、掉帧等情况</p> <p>查看页面的长任务：</p> <p>打开控制台，选择 Performance 工具，点击 Start 按钮，展开 Main 选项，会发现有很多红色的三角，这些就属于长任务（长任务：执行时间超过 50ms 的任务）</p> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0qqAf7Dwl71Gs42cibOJ8iaCuvD369QQBUrHxicUPwB353kJjaIH7L0esw/640?" alt="图片"></p> <p>测试实验：</p> <p>如果直接把下面这段代码直接丢到主线程中，计算过程中页面一直处于卡死状态，无法操作</p> <div class="language- extra-class"><pre class="language-text"><code>let sum = 0;
for (let i = 0; i &lt; 200000; i++) {
    for (let i = 0; i &lt; 10000; i++) {
      sum += Math.random()
    }
  }
</code></pre></div><p>使用 Web Worker 执行上述代码时，计算过程中页面正常可操作、无卡顿</p> <div class="language- extra-class"><pre class="language-text"><code>// worker.js
onmessage = function (e) {
  // onmessage获取传入的初始值
  let sum = e.data;
  for (let i = 0; i &lt; 200000; i++) {
    for (let i = 0; i &lt; 10000; i++) {
      sum += Math.random()
    }
  }
  // 将计算的结果传递出去
  postMessage(sum);
}
</code></pre></div><p>Web Worker 具体的使用与案例，详情见 <strong>一文彻底了解 Web Worker，十万、百万条数据都是弟弟 🔥</strong></p> <h3 id="web-worker-的通信时长"><a href="#web-worker-的通信时长" class="header-anchor">#</a> Web Worker 的通信时长</h3> <p>并不是执行时间超过 50ms 的任务，就可以使用 Web Worker，还要先考虑<code>通信时长</code>的问题</p> <p>假如一个运算执行时长为 100ms，但是通信时长为 300ms， 用了 Web Worker 可能会更慢</p> <p>比如新建一个 web worker, 浏览器会加载对应的 worker.js 资源，下图中的 Time 是这个资源的通信时长（也叫加载时长）</p> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU046RMbyicGhu0QzOZia5qLv73JOxxg8LUb5JYeghjBL3AcoS9hoibdKNew/640?" alt="图片"></p> <p><strong>「当任务的运算时长 - 通信时长 &gt; 50ms，推荐使用 Web Worker」</strong></p> <h2 id="_7、requestanimationframe-制作动画"><a href="#_7、requestanimationframe-制作动画" class="header-anchor">#</a> 7、requestAnimationFrame 制作动画</h2> <p><code>requestAnimationFrame</code> 是浏览器专门为动画提供的 API，它的刷新频率与显示器的频率保持一致，使用该 api 可以解决用 setTimeout/setInterval 制作动画卡顿的情况</p> <p>1）引擎层面</p> <p>setTimeout/setInterval 属于 <code>JS引擎</code>，requestAnimationFrame 属于 <code>GUI引擎</code></p> <p><code>JS引擎与GUI引擎</code>是互斥的，也就是说 GUI 引擎在渲染时会阻塞 JS 引擎的计算</p> <p>2）时间是否准确</p> <p>requestAnimationFrame 刷新频率是固定且准确的，但 setTimeout/setInterval 是宏任务，根据事件轮询机制，其他任务会阻塞或延迟 js 任务的执行，会出现定时器不准的情况</p> <p>3）性能层面</p> <p>当页面被隐藏或最小化时，setTimeout/setInterval 定时器仍会在后台执行动画任务，而使用 requestAnimationFrame 当页面处于未激活的状态下，屏幕刷新任务会被系统暂停</p> <h2 id="_8、js-的-6-种加载方式"><a href="#_8、js-的-6-种加载方式" class="header-anchor">#</a> 8、JS 的 6 种加载方式</h2> <h3 id="_1-正常模式"><a href="#_1-正常模式" class="header-anchor">#</a> 1）正常模式</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;
</code></pre></div><p>这种情况下 JS 会阻塞 dom 渲染，浏览器必须等待 index.js 加载和执行完成后才能去做其它事情</p> <h3 id="_2-async-模式"><a href="#_2-async-模式" class="header-anchor">#</a> 2）async 模式</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;script async src=&quot;index.js&quot;&gt;&lt;/script&gt;
</code></pre></div><p>async 模式下，它的加载是异步的，JS 不会阻塞 DOM 的渲染，async 加载是无顺序的，当它加载结束，JS 会立即执行</p> <p>使用场景：若该 JS 资源与 DOM 元素没有依赖关系，也不会产生其他资源所需要的数据时，可以使用 async 模式，比如埋点统计</p> <h3 id="_3-defer-模式"><a href="#_3-defer-模式" class="header-anchor">#</a> 3）defer 模式</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;script defer src=&quot;index.js&quot;&gt;&lt;/script&gt;
</code></pre></div><p>defer 模式下，JS 的加载也是异步的，defer 资源会在  <code>DOMContentLoaded</code> 执行之前，并且 defer 是有顺序的加载</p> <p>如果有多个设置了 defer 的 script 标签存在，则会按照引入的前后顺序执行，即便是后面的 script 资源先返回</p> <p>所以 defer 可以用来控制 JS 文件的执行顺序，比如 element-ui.js 和 vue.js，因为 element-ui.js 依赖于 vue，所以必须先引入 vue.js，再引入 element-ui.js</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script defer src=&quot;vue.js&quot;&gt;&lt;/script&gt;
&lt;script defer src=&quot;element-ui.js&quot;&gt;&lt;/script&gt;
</code></pre></div><p>defer 使用场景：一般情况下都可以使用 defer，特别是需要控制资源加载顺序时</p> <h3 id="_4-module-模式"><a href="#_4-module-模式" class="header-anchor">#</a> 4）module 模式</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;script type=&quot;module&quot;&gt;import { a } from './a.js'&lt;/script&gt;
</code></pre></div><p>在主流的现代浏览器中，script 标签的属性可以加上  <code>type=&quot;module&quot;</code>，浏览器会对其内部的 import 引用发起 HTTP 请求，获取模块内容。这时 script 的行为会像是  defer 一样，在后台下载，并且等待 DOM 解析</p> <p>Vite 就是利用浏览器支持原生的 <code>es module</code> 模块，开发时跳过打包的过程，提升编译效率</p> <h3 id="_5-preload"><a href="#_5-preload" class="header-anchor">#</a> 5） preload</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;link rel=&quot;preload&quot; as=&quot;script&quot; href=&quot;index.js&quot;&gt;
</code></pre></div><p>link 标签的 preload 属性：用于提前加载一些需要的依赖，这些资源会优先加载</p> <p>vue2 项目打包生成的 index.html 文件，会自动给首页所需要的资源，全部添加 preload，实现关键资源的提前加载</p> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0EgHd0g3CmZvomcWbozaia2YIZry8WlJofrlSu4vy0d3S4CSq9NSHmcQ/640?" alt="图片"></p> <p>preload 特点：</p> <p>1）preload 加载的资源是在浏览器渲染机制之前进行处理的，并且不会阻塞 onload 事件；</p> <p>2）preload 加载的 JS 脚本其加载和执行的过程是分离的，即 preload 会预加载相应的脚本代码，待到需要时自行调用；</p> <h3 id="_6-prefetch"><a href="#_6-prefetch" class="header-anchor">#</a> 6）prefetch</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;link rel=&quot;prefetch&quot; as=&quot;script&quot; href=&quot;index.js&quot;&gt;
</code></pre></div><p>prefetch 是利用浏览器的空闲时间，加载页面将来可能用到的资源的一种机制；通常可以用于加载其他页面（非首页）所需要的资源，以便加快后续页面的打开速度</p> <p>prefetch 特点：</p> <p>1）pretch 加载的资源可以获取非当前页面所需要的资源，并且将其放入缓存至少 5 分钟（无论资源是否可以缓存）</p> <p>2）当页面跳转时，未完成的 prefetch 请求不会被中断</p> <h3 id="加载方式总结"><a href="#加载方式总结" class="header-anchor">#</a> 加载方式总结</h3> <p>async、defer 是  script 标签的专属属性，对于网页中的其他资源，可以通过  link 的 preload、prefetch 属性来预加载</p> <p>如今现代框架已经将 preload、prefetch 添加到打包流程中了，通过灵活的配置，去使用这些预加载功能，同时我们也可以审时度势地向 script 标签添加 async、defer 属性去处理资源，这样可以显著提升性能</p> <h2 id="_9、图片的优化"><a href="#_9、图片的优化" class="header-anchor">#</a> 9、图片的优化</h2> <p>平常大部分性能优化工作都集中在 JS 方面，但图片也是页面上非常重要的部分</p> <p>特别是对于移动端来说，完全没有必要去加载原图，浪费带宽。如何去压缩图片，让图片更快的展示出来，有很多优化工作可以做</p> <p>淘宝首页的图片资源都很小：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0bNfkj3c6EXp34ibNlI0qNyOFG5SvR2g2YaBXphEE69iaaHnRiapupR2tQ/640?" alt="图片"></p> <h3 id="图片的动态裁剪"><a href="#图片的动态裁剪" class="header-anchor">#</a> 图片的动态裁剪</h3> <p>很多云服务，比如<strong>阿里云</strong>或<strong>七牛云</strong>，都提供了图片的动态裁剪功能，效果很棒，确实是钱没有白花</p> <p>只需在图片的 url 地址上动态添加参数，就可以得到你所需要的尺寸大小，比如：<code>http://7xkv1q.com1.z0.glb.clouddn.com/grape.jpg?imageView2/1/w/200/h/200</code></p> <p>图片瘦身前后对比：</p> <ul><li>原图：<code>1.8M</code></li></ul> <p><img src="https://mmbiz.qpic.cn/mmbiz/kzFgl6ibibNKrZHibtkKwAOCg3SPmOa2vU0dNKrFzDuIiaQAPfbHMuUS04YibVZVqffuNREN9VticstBkcZLWkRYBKqQ/640?" alt="图片"></p> <ul><li>裁剪后：<code>12.8KB</code></li></ul> <p>经过动态裁剪后的图片，加载速度会有非常明显的提升</p> <h3 id="图片的懒加载"><a href="#图片的懒加载" class="header-anchor">#</a> 图片的懒加载</h3> <p>对于一些图片量比较大的首页，用户打开页面后，只需要呈现出在屏幕可视区域内的图片，当用户滑动页面时，再去加载出现在屏幕内的图片，以优化图片的加载效果</p> <p>图片懒加载实现原理：</p> <p>由于浏览器会自动对页面中的 img 标签的 src 属性发送请求并下载图片，可以通过 html5 自定义属性 data-xxx 先暂存 src 的值，然后在图片出现在屏幕可视区域的时候，再将 data-xxx 的值重新赋值到 img 的 src 属性即可</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;img src=&quot;&quot; alt=&quot;&quot; data-src=&quot;./images/1.jpg&quot;&gt;
&lt;img src=&quot;&quot; alt=&quot;&quot; data-src=&quot;./images/2.jpg&quot;&gt;
</code></pre></div><p>这里以 <code>vue-lazyload</code> 插件为例</p> <div class="language- extra-class"><pre class="language-text"><code>// 安装
npm install vue-lazyload

// main.js 注册
import VueLazyload from 'vue-lazyload'
Vue.use(VueLazyload)
// 配置项
Vue.use(VueLazyload, {
  preLoad: 1.3,
  error: 'dist/error.png', // 图片加载失败时的占位图
  loading: 'dist/loading.gif', // 图片加载中时的占位图
  attempt: 1
})

// 通过 v-lazy 指令使用
&lt;ul&gt;
    &lt;li v-for=&quot;img in list&quot;&gt;
        &lt;img v-lazy=&quot;img.src&quot; :key=&quot;img.src&quot; &gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre></div><h3 id="使用字体图标"><a href="#使用字体图标" class="header-anchor">#</a> 使用字体图标</h3> <p>字体图标是页面使用小图标的不二选择，最常用的就是 <strong>iconfont</strong></p> <p>字体图标的优点：</p> <p>1）轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了 http 请求</p> <p>2）灵活性：可以随意的改变颜色、产生阴影、透明效果、旋转等</p> <p>3）兼容性：几乎支持所有的浏览器，请放心使用</p> <h3 id="图片转-base64-格式"><a href="#图片转-base64-格式" class="header-anchor">#</a> 图片转 base64 格式</h3> <p>将小图片转换为 base64 编码字符串，并写入 HTML 或者 CSS 中，减少 http 请求</p> <p>转 base64 格式的优缺点：</p> <p>1）它处理的往往是非常小的图片，因为 Base64 编码后，图片大小会膨胀为原文件的 4/3，如果对大图也使用 Base64 编码，后者的体积会明显增加，即便减少了 http 请求，也无法弥补这庞大的体积带来的性能开销，得不偿失</p> <p>2）在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 http 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势</p> <p>项目可以使用 <code>url-loader</code> 将图片转 base64：</p> <div class="language- extra-class"><pre class="language-text"><code>// 安装
npm install url-loader --save-dev

// 配置
module.exports = {
  module: {
    rules: [{
        test: /.(png|jpg|gif)$/i,
        use: [{
            loader: 'url-loader',
            options: {
              // 小于 10kb 的图片转化为 base64
              limit: 1024 * 10
            }
        }]
     }]
  }
};
</code></pre></div><h2 id="优化总结"><a href="#优化总结" class="header-anchor">#</a> 优化总结</h2> <p>本文主要介绍的是 <strong>「代码层面」</strong> 的性能优化，经过上面的一系列优化，首页打开速度有了明显的提升，虽然都是一些常规方案，但其中可以深挖的知识点并不少</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最近更新时间：:</span> <span class="time">3/28/2023, 9:51:31 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/yx_blog/views/vue/optimazition.html" class="prev">
        vue项目优化
      </a></span> <span class="next"><a href="/yx_blog/views/vue/vue3.html">
        Vue3
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/yx_blog/assets/js/app.e0a8f1e5.js" defer></script><script src="/yx_blog/assets/js/2.95e582b3.js" defer></script><script src="/yx_blog/assets/js/29.5ca16a60.js" defer></script>
  </body>
</html>
